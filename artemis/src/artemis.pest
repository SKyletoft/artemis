lower_case =  { 'a'..'z' | "Ã¥" | "Ã¤" | "Ã¶" }
upper_case =  { 'A'..'Z' | "Ã…" | "Ã„" | "Ã–" }
digit      =  { '0'..'9' }
whitespace = _{ (" " | "\t" | "\r" | "\n")+ }
greek      =  {
	"Î±" | "Î²" | "Î“" | "Î³" | "Îµ" | "Î¶" | "Î·" | "Î˜" | "Î¸" | "Î¹" | "Îš" |
	"Îº" | "Î¼" | "Î½" | "Îž" | "Î¾" | "Î " | "Ï€" | "Ï" | "Î£" | "Ïƒ" | "Ï‚" |
	"Ï„" | "Ï…" | "Î¦" | "Ï†" | "Î§" | "Ï‡" | "Î¨" | "Ïˆ" | "Î©" | "Ï‰"
}

large_metric_prefix = { "D" | "da"| "h" | "k" | "M" | "G" | "T" | "P" | "E" | "Z" | "Y" }
small_metric_prefix = { "d" | "c" | "m" | "Î¼" | "u" | "n" | "p" | "f" | "a" | "z" | "y" }
metrix_prefix       = { small_metric_prefix | large_metric_prefix }
binary_prefix       = { "ki" | "Mi" | "Gi" | "Ti" | "Pi" | "Ei" | "Zi" | "Yi" }

ws = _{ whitespace? }

var_name     = { (lower_case ~ (lower_case | digit | "_")*) | greek }
type_name    = { (mutable ~ whitespace)? ~ raw_type }
mutable      = { "mut" }
raw_type     = { native_types | struct_name | unit | tuple_type }
native_types = { "â„•" | "â„" | "â„¤" | "ð”¹" }
struct_name  = { upper_case ~ (upper_case | lower_case | digit)* }
tuple_type   = { "(" ~ ws ~ type_name ~ (ws ~ "," ~ ws ~ type_name)+ ~ ws ~ ")" }

dot   = { "." | "`dot`" }
plus  = { "+" | "`add`" }
minus = { "-" | "`sub`" }
delta = { "Î´" | "`delta`" }
times = { "*" | "Ã—" | "Â·" | "`mul`" }
div   = { "/" | "Ã·" | "`div`" }
exp   = { "^" | "`exp`" }
not   = { "Â¬" | "`not`" }
and   = { "Î›" | "âˆ§" | "â‹€" | "`and`" }
or    = { "V" | "âˆ¨" | "â‹" | "`or`" }
xor   = { "âŠ•" | "âŠ»" | "â¨" | "(+)" | "`xor`" }

integer =  { (plus | minus)? ~ digit+ ~ (metrix_prefix | binary_prefix)? }
float   =  { (plus | minus)? ~ digit+ ~ dot ~ digit* ~ (metrix_prefix | binary_prefix)? }
boolean =  { "ð•‹" | "ð”½" | "true" | "false" }
unit    =  { "(" ~ ws ~ ")" }
tuple   =  { "(" ~ ws ~ expr ~ (ws ~ "," ~ ws ~ expr)+ ~ ws ~ ")" }
string  = ${ "\"" ~ inner_s ~ "\"" }
char    =  { "'" ~ single_char ~ "'" }

inner_s     = @{ single_char* }
single_char =  {
	!("\"" | "\\") ~ ANY
	| "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
	| "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

declaration   = { var_name ~ ws ~ ":" ~ ws ~ type_name? ~ ws ~ "=" ~ ws ~ expr }
assignment    = { var_name ~ ws ~ binary_operator? ~ "=" ~ ws ~ expr }
function_call = { var_name ~ ws ~ "(" ~ ws ~ ((expr ~ ws ~ "," ~ ws)* ~ ws ~ expr)? ~ ws ~ ")" }

if_expr = {
	("?" | "if" | "`if`" ) ~ ws ~ expr ~ ws ~
	expr ~ ws ~
	("|" | "else" | "`else`" ) ~ ws ~ expr
}
expr = {
	declaration
	| assignment
	| unary_operator ~ ws ~ term
	| term ~ (ws ~ binary_operator ~ ws ~ term)*
}

term = {
	float
	| integer
	| boolean
	| string
	| char
	| unit
	| tuple
	| block
	| if_expr
	| function_call
	| declaration
	| assignment
	| var_name
}
binary_operator = { exp | times | div | plus | minus | delta | and | or | xor }
unary_operator  = { not | minus }

fn_keyword = { "\\" | "Î»" | "fn" }
argument   = { var_name ~ ws ~ ":" ~ ws ~ type_name }

function_definition = {
	fn_keyword ~ ws ~ var_name ~ ws ~ "(" ~ ws ~
	((argument ~ ws ~ "," ~ ws)* ~ argument)* ~ ws ~
	")" ~ ws ~ (("->" | "â†’") ~ ws ~ raw_type)? ~ ws ~ "=" ~ ws ~ expr
}
block = { "{" ~ ws ~ (expr ~ (("\n" | "\r\n" | ";")+ ~ ws ~ expr)*) ~ ws ~ "}" }

struct_enum_field = { var_name ~ ws ~ ":" ~ ws ~ raw_type }
struct_definition = {
	(times | "struct") ~ ws ~ struct_name ~ ws ~ "{" ~ ws ~
	((struct_enum_field ~ ws ~ "," ~ ws)* ~ struct_enum_field)* ~ ws ~ "}"
}
enum_definition = {
	(plus  | "enum") ~ ws ~ struct_name ~ ws ~ "{" ~ ws ~
	((struct_enum_field ~ ws ~ "," ~ ws)* ~ struct_enum_field)* ~ ws ~ "}"
}

top = { SOI ~ ws ~ (function_definition ~ ws)* ~ ws ~ EOI }

